from abc import ABC, abstractmethod
import numpy as np
from electronTransportCode.MCEstimator import MCEstimator
from electronTransportCode.ParticleModel import ParticleModel
from electronTransportCode.SimOptions import SimOptions
from electronTransportCode.ProjectUtils import tuple2d
from electronTransportCode.SimulationDomain import SimulationDomain


class MCParticleTracer(ABC):
    """General Monte Carlo particle tracer object for radiation therapy
    """
    def __init__(self, particle: ParticleModel, simOptions: SimOptions, simDomain: SimulationDomain) -> None:
        self.particle = particle
        self.simOptions = simOptions
        self.simDomain = simDomain

        self.particle.setGenerator(self.simOptions.rng)  # Have all random numbers in simulation be generated by the same generator object

    def __call__(self, nbParticles: int, estimator: MCEstimator) -> None:
        """Execute Monte Carlo particle simulation of self.particle using self.simOptions in the simulation domain defined by self.simDomain.
        Quantities of interest are estimated on-the-fly using estimator.

        Args:
            estimator (MCEstimator): Estimator object which implements scoring of all quantities of interest

        """
        for _ in range(nbParticles):
            # simulate particle
            self.traceParticle(estimator)

        return None

    def energyLoss(self, Ekin: float, stepsize: float, index: int) -> float:
        """Compute energy along step using continuous slowing down approximation. Eq. 4.11.3 from EGSnrc manual, also used in GPUMCD.
        Approximation is second order accurate: O(DeltaE^2)

        Args:
            Ekin (float): Energy at the beginning of the step. Energy unit relative to electron rest energy.
            stepsize (float): [cm] path-length

        Returns:
            float: Energy loss DeltaE
        """
        Emid = Ekin + self.particle.evalStoppingPower(Ekin, self.simDomain.getMaterial(index))*stepsize/2
        return self.particle.evalStoppingPower(Emid, self.simDomain.getMaterial(index))*stepsize

    @abstractmethod
    def traceParticle(self, estimator: MCEstimator) -> None:
        """Simulate one particle
        """


class AnalogParticleTracer(MCParticleTracer):
    """Analog particle tracing algorithm
    """
    def traceParticle(self, estimator: MCEstimator) -> None:
        """Step particle through simulation domain until its energy is below a threshold value. Estimator routine is called after each step for on-the-fly estimation.

        Args:
            estimator (MCEstimator): Estimator object which implements scoring of all quantities of interest

        """
        # Sample initial condition
        pos: tuple2d = self.simOptions.initialPosition()
        vec: tuple2d = self.simOptions.initialDirection()
        energy: float = self.simOptions.initialEnergy()
        index: int = self.simDomain.getIndexPath(pos, vec)

        loopbool: bool = True

        # Do type annotations for updated positions
        new_pos: tuple2d
        new_vec: tuple2d
        new_energy: float
        new_index: int

        counter = 0
        # Step untill energy is smaller than threshold
        while loopbool:
            new_pos, new_vec, new_energy, new_index = self.stepParticle(pos, vec, energy, index)
            if new_energy < self.simOptions.minEnergy:
                new_energy = 0  # have estimator deposit all energy
                loopbool = False  # make this the last iterations
            estimator.updateEstimator((pos, new_pos), (vec, new_vec), (energy, new_energy), index)
            pos = new_pos
            vec = new_vec
            energy = new_energy
            index = new_index

            # Logging
            counter += 1
            if counter % 10000 == 0:
                print(energy, counter)

        return None

    def stepParticle(self, pos: tuple2d, vec: tuple2d, energy: float, index: int) -> tuple[tuple2d, tuple2d, float, int]:
        """Transport particle and apply event.
        Algorithm:
            - Sample step size
                - collisional step size
                - grid cell or domain edge step size

            - Apply step
                - Change position
                - Decrement energy

            - If next event is a collision
                - Sample a new post-collisional direction
                - Keep index

            - If next event is a boundary crossing
                - Keep post-collisional direction
                - Update index

            - If next event is a domain edge collision
                - Set energy to zero
                - Stop simulation by setting energy (weight) to zero

        Args:
            pos (tuple2d): particle position at start of method
            vec (tuple2d): particle orientation at start of method
            energy (float): particle energy at start of method
            index (int): particle position in self.simDomain at start of method

        Returns:
            tuple[tuple2d, tuple2d, float, int]: state of particle after being transported to new event location and having that event applied.
        """

        # Sample step size
        stepColl = self.particle.samplePathlength(energy, self.simDomain.getMaterial(index))
        stepGeom, neighbourCellIndex = self.simDomain.getCellEdgeInformation(pos, vec, index)
        step = min(stepColl, stepGeom)

        # Apply step
        new_pos = pos + step*vec  # type: ignore

        # Decrement energy along step
        deltaE = self.energyLoss(energy, step, index)
        new_energy = energy - deltaE

        # Select event
        if stepColl < stepGeom:  # Next event is collision
            new_vec: tuple2d = np.zeros_like(vec, dtype=float)
            new_index = index
            cost = self.particle.sampleAngle(new_energy, self.simDomain.getMaterial(index))  # anisotropic scattering angle (mu)
            sign = self.simOptions.rng.choice([-1, 1])
            sint = np.sqrt(1 - cost**2)*sign  # scatter left or right with equal probability
            new_vec[0] = vec[0]*cost - vec[1]*sint
            new_vec[1] = vec[0]*sint + vec[1]*cost
            new_vec = new_vec/np.linalg.norm(new_vec)  # normalized for security

        else:  # Next event is grid cell crossing
            new_index = neighbourCellIndex
            new_vec = vec
            if neighbourCellIndex == -1:  # Next event is domain edge crossing
                new_energy = 0

        assert self.simDomain.getIndexPath(new_pos, new_vec) == new_index
        assert np.isclose(np.linalg.norm(vec), 1, rtol=1e-10), f'norm of vector: {np.linalg.norm(vec)}'
        assert np.isnan(new_energy) == False, f'{new_energy}, {np.isnan(new_energy)}, {np.isnan(new_energy) is False}'
        return new_pos, new_vec, new_energy, new_index
